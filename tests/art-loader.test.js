/**
 * art-loader unit tests
 * Detected test framework: vitest
 * Feature flags (from static analysis): { async: 0, callback: 0, cacheable: 0, getOptions: 0, raw: 0, emitError: 0 }
 * Auto-generated by CodeRabbit Inc. on 2025-09-20.
 * NOTE: Tests are written to run under Jest/Vitest/Mocha using Node's assert to avoid extra deps.
 */
/* eslint-disable no-undef, no-console, global-require, import/no-dynamic-require */
const assert = require('assert');
const path = require('path');

const FEATURE_FLAGS = Object.freeze({
  HAS_ASYNC: 0,
  HAS_CALLBACK: 0,
  HAS_CACHEABLE: 0,
  HAS_GETOPTIONS: 0,
  HAS_RAW: 0,
  HAS_EMITERROR: 0
});

// Resolve loader module path relative to this test file
const LOADER_PATH = path.resolve(__dirname, '../assets/js/art-loader.js');
let loader;
try {
  loader = require(LOADER_PATH);
  // Support ESM default export interop if applicable
  loader = loader && loader.__esModule && loader.default ? loader.default : loader;
} catch (e) {
  // If the module cannot be required, mark tests as skipped in a framework-agnostic way
  // We still define a no-op describe/it if not provided (for environments like tap/ava, this block won't run)
  const _describe = (typeof describe === 'function') ? describe : (name, fn) => { console.warn("SKIP suite:", name, "- art-loader module not found:", LOADER_PATH); };
  const _it = (typeof it === 'function') ? it : ((name, fn) => { console.warn("SKIP test:", name); });
  _describe('art-loader (module missing)', () => {
    _it('skips because art-loader module was not found at ' + LOADER_PATH, () => {
      assert.ok(true);
    });
  });
  // Early return from file by throwing a controlled exception that frameworks ignore (caught below)
  // Instead of throwing, simply return by short-circuiting further definitions
}
if (!loader) {
  // Prevent reference errors if loader missing (no-op)
} else {

  function createMockLoaderContext(overrides = {}) {
    const calls = { async: 0, callback: 0, cacheable: 0, emitError: 0, emitWarning: 0, addDependency: 0, addContextDependency: 0 };
    let asyncCb = null;

    const ctx = {
      version: 2,
      query: {},
      getOptions() { return overrides.options || ctx.query || {}; },
      resourcePath: overrides.resourcePath || path.resolve(__dirname, 'fixtures', 'sample.art'),
      rootContext: overrides.rootContext || path.resolve(__dirname, '..'),
      context: overrides.context || path.resolve(__dirname, '..'),
      addDependency(dep) { calls.addDependency++; },
      addContextDependency(dep) { calls.addContextDependency++; },
      cacheable(flag) { calls.cacheable++; },
      emitError(err) { calls.emitError++; if (typeof err === 'string') err = new Error(err); if (asyncCb) asyncCb(err); },
      emitWarning(msg) { calls.emitWarning++; },
      async() { calls.async++; return (err, result) => { calls.callback++; if (asyncCb) asyncCb(err, result); }; },
      callback(err, result) { calls.callback++; if (asyncCb) asyncCb(err, result); },
      ...overrides
    };

    return { ctx, calls, onAsync: (cb) => { asyncCb = cb; } };
  }

  async function runLoaderWithSource(source, options = {}, ctxOverrides = {}) {
    const { ctx, calls, onAsync } = createMockLoaderContext({ ...ctxOverrides, options });
    const loaderFn = (typeof loader === 'function') ? loader : (loader && loader.default) ? loader.default : loader;
    assert.strictEqual(typeof loaderFn, 'function', 'art-loader must export a function');

    return await new Promise((resolve, reject) => {
      let settled = false;
      const done = (err, result) => {
        if (settled) return;
        settled = true;
        if (err) reject(Object.assign(err, { calls }));
        else resolve({ code: result, calls });
      };

      onAsync(done);

      try {
        const ret = loaderFn.call(ctx, source);
        // Sync path: if a return value is provided and callback/async not used
        setImmediate(() => {
          if (settled) return;
          if (typeof ret !== 'undefined') {
            settled = true;
            resolve({ code: ret, calls });
          } else {
            // Neither ret nor async used conclusively; resolve to undefined code but with call counts
            settled = true;
            resolve({ code: undefined, calls });
          }
        });
      } catch (err) {
        settled = true;
        reject(Object.assign(err, { calls }));
      }
    });
  }

  const _describe = (typeof describe === 'function') ? describe : (name, fn) => fn && fn();
  const _it = (typeof it === 'function') ? it : (name, fn) => fn && fn();

  _describe('art-loader', () => {

    _it('exports a function', () => {
      const fn = (typeof loader === 'function') ? loader : (loader && loader.default) ? loader.default : loader;
      assert.strictEqual(typeof fn, 'function');
    });

    _it('processes simple string input without throwing', async () => {
      const { code } = await runLoaderWithSource('/* sample input */', {});
      assert.ok(code === undefined || typeof code === 'string' || Buffer.isBuffer(code), 'result should be string, Buffer, or undefined (callback path)');
    });

    _it('handles Buffer input', async () => {
      const src = Buffer.from('/* buffer input */');
      const { code } = await runLoaderWithSource(src, {});
      assert.ok(code === undefined || typeof code === 'string' || Buffer.isBuffer(code));
    });

    _it('accepts options object (if read via getOptions/query)', async () => {
      const options = { debug: true, __testFlag: 'ok' };
      const { code } = await runLoaderWithSource('/* opt input */', options);
      assert.ok(code === undefined || typeof code === 'string' || Buffer.isBuffer(code));
    });

    if (FEATURE_FLAGS.HAS_CACHEABLE) {
      _it('invokes cacheable when available', async () => {
        const { calls } = await runLoaderWithSource('/* cacheable check */', {});
        assert.ok(calls.cacheable >= 1, 'expected loader to call this.cacheable() at least once');
      });
    }

    if (FEATURE_FLAGS.HAS_ASYNC || FEATURE_FLAGS.HAS_CALLBACK) {
      _it('supports async/callback semantics', async () => {
        const { calls } = await runLoaderWithSource('/* async check */', {});
        assert.ok(calls.async >= 1 || calls.callback >= 1, 'expected loader to use async/callback path');
      });
    }

    if (FEATURE_FLAGS.HAS_RAW) {
      _it('accepts raw Buffer sources (raw=true)', async () => {
        const buf = Buffer.from([0,1,2,3,4,5]);
        const { code } = await runLoaderWithSource(buf, {});
        assert.ok(code === undefined || typeof code === 'string' || Buffer.isBuffer(code));
      });
    }

    _it('gracefully handles unexpected input types (edge case)', async () => {
      try {
        await runLoaderWithSource(42, {}); // non-string, non-buffer
        assert.ok(true, 'loader handled unexpected input without uncaught exception');
      } catch (err) {
        assert.ok(err instanceof Error, 'should reject with an Error on invalid input');
      }
    });

  });
}